"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from .httpclient import AsyncHttpClient, ClientOwner, HttpClient, close_clients
from .sdkconfiguration import SDKConfiguration
from .utils.logger import Logger, get_default_logger
from .utils.retries import RetryConfig
import httpx
import importlib
from openrouter import components, utils
from openrouter._hooks import SDKHooks
from openrouter.models import internal
from openrouter.types import OptionalNullable, UNSET
import sys
from typing import Any, Callable, Dict, Optional, TYPE_CHECKING, Union, cast
import weakref

if TYPE_CHECKING:
    from openrouter.analytics import Analytics
    from openrouter.api_keys import APIKeys
    from openrouter.beta import Beta
    from openrouter.chat import Chat
    from openrouter.credits import Credits
    from openrouter.embeddings import Embeddings
    from openrouter.endpoints import Endpoints
    from openrouter.generations import Generations
    from openrouter.guardrails import Guardrails
    from openrouter.models_ import Models
    from openrouter.oauth import OAuth
    from openrouter.providers import Providers


class OpenRouter(BaseSDK):
    r"""OpenRouter API: OpenAI-compatible API with additional OpenRouter features
    https://openrouter.ai/docs - OpenRouter Documentation
    """

    beta: "Beta"
    analytics: "Analytics"
    r"""Analytics and usage endpoints"""
    credits: "Credits"
    r"""Credit management endpoints"""
    embeddings: "Embeddings"
    r"""Text embedding endpoints"""
    generations: "Generations"
    r"""Generation history endpoints"""
    models: "Models"
    r"""Model information endpoints"""
    endpoints: "Endpoints"
    r"""Endpoint information"""
    providers: "Providers"
    r"""Provider information endpoints"""
    api_keys: "APIKeys"
    r"""API key management endpoints"""
    guardrails: "Guardrails"
    r"""Guardrails endpoints"""
    o_auth: "OAuth"
    r"""OAuth authentication endpoints"""
    chat: "Chat"
    _sub_sdk_map = {
        "beta": ("openrouter.beta", "Beta"),
        "analytics": ("openrouter.analytics", "Analytics"),
        "credits": ("openrouter.credits", "Credits"),
        "embeddings": ("openrouter.embeddings", "Embeddings"),
        "generations": ("openrouter.generations", "Generations"),
        "models": ("openrouter.models_", "Models"),
        "endpoints": ("openrouter.endpoints", "Endpoints"),
        "providers": ("openrouter.providers", "Providers"),
        "api_keys": ("openrouter.api_keys", "APIKeys"),
        "guardrails": ("openrouter.guardrails", "Guardrails"),
        "o_auth": ("openrouter.oauth", "OAuth"),
        "chat": ("openrouter.chat", "Chat"),
    }

    def __init__(
        self,
        api_key: Optional[Union[Optional[str], Callable[[], Optional[str]]]] = None,
        http_referer: Optional[str] = None,
        x_title: Optional[str] = None,
        server: Optional[str] = None,
        server_url: Optional[str] = None,
        url_params: Optional[Dict[str, str]] = None,
        client: Optional[HttpClient] = None,
        async_client: Optional[AsyncHttpClient] = None,
        retry_config: OptionalNullable[RetryConfig] = UNSET,
        timeout_ms: Optional[int] = None,
        debug_logger: Optional[Logger] = None,
    ) -> None:
        r"""Instantiates the SDK configuring it with the provided parameters.

        :param api_key: The api_key required for authentication
        :param http_referer: Configures the http_referer parameter for all supported operations
        :param x_title: Configures the x_title parameter for all supported operations
        :param server: The server by name to use for all methods
        :param server_url: The server URL to use for all methods
        :param url_params: Parameters to optionally template the server URL with
        :param client: The HTTP client to use for all synchronous methods
        :param async_client: The Async HTTP client to use for all asynchronous methods
        :param retry_config: The retry configuration to use for all supported methods
        :param timeout_ms: Optional request timeout applied to each operation in milliseconds
        """
        client_supplied = True
        if client is None:
            client = httpx.Client(follow_redirects=True)
            client_supplied = False

        assert issubclass(
            type(client), HttpClient
        ), "The provided client must implement the HttpClient protocol."

        async_client_supplied = True
        if async_client is None:
            async_client = httpx.AsyncClient(follow_redirects=True)
            async_client_supplied = False

        if debug_logger is None:
            debug_logger = get_default_logger()

        assert issubclass(
            type(async_client), AsyncHttpClient
        ), "The provided async_client must implement the AsyncHttpClient protocol."

        security: Any = None
        if callable(api_key):
            # pylint: disable=unnecessary-lambda-assignment
            security = lambda: components.Security(api_key=api_key())
        else:
            security = components.Security(api_key=api_key)

        if server_url is not None:
            if url_params is not None:
                server_url = utils.template_url(server_url, url_params)

        _globals = internal.Globals(
            http_referer=utils.get_global_from_env(
                http_referer, "OPENROUTER_HTTP_REFERER", str
            ),
            x_title=utils.get_global_from_env(x_title, "OPENROUTER_X_TITLE", str),
        )

        BaseSDK.__init__(
            self,
            SDKConfiguration(
                client=client,
                client_supplied=client_supplied,
                async_client=async_client,
                async_client_supplied=async_client_supplied,
                globals=_globals,
                security=security,
                server_url=server_url,
                server=server,
                retry_config=retry_config,
                timeout_ms=timeout_ms,
                debug_logger=debug_logger,
            ),
            parent_ref=self,
        )

        hooks = SDKHooks()

        # pylint: disable=protected-access
        self.sdk_configuration.__dict__["_hooks"] = hooks

        self.sdk_configuration = hooks.sdk_init(self.sdk_configuration)

        weakref.finalize(
            self,
            close_clients,
            cast(ClientOwner, self.sdk_configuration),
            self.sdk_configuration.client,
            self.sdk_configuration.client_supplied,
            self.sdk_configuration.async_client,
            self.sdk_configuration.async_client_supplied,
        )

    def dynamic_import(self, modname, retries=3):
        for attempt in range(retries):
            try:
                return importlib.import_module(modname)
            except KeyError:
                # Clear any half-initialized module and retry
                sys.modules.pop(modname, None)
                if attempt == retries - 1:
                    break
        raise KeyError(f"Failed to import module '{modname}' after {retries} attempts")

    def __getattr__(self, name: str):
        if name in self._sub_sdk_map:
            module_path, class_name = self._sub_sdk_map[name]
            try:
                module = self.dynamic_import(module_path)
                klass = getattr(module, class_name)
                instance = klass(self.sdk_configuration, parent_ref=self)
                setattr(self, name, instance)
                return instance
            except ImportError as e:
                raise AttributeError(
                    f"Failed to import module {module_path} for attribute {name}: {e}"
                ) from e
            except AttributeError as e:
                raise AttributeError(
                    f"Failed to find class {class_name} in module {module_path} for attribute {name}: {e}"
                ) from e

        raise AttributeError(
            f"'{type(self).__name__}' object has no attribute '{name}'"
        )

    def __dir__(self):
        default_attrs = list(super().__dir__())
        lazy_attrs = list(self._sub_sdk_map.keys())
        return sorted(list(set(default_attrs + lazy_attrs)))

    def __enter__(self):
        return self

    async def __aenter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if (
            self.sdk_configuration.client is not None
            and not self.sdk_configuration.client_supplied
        ):
            self.sdk_configuration.client.close()
        self.sdk_configuration.client = None

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if (
            self.sdk_configuration.async_client is not None
            and not self.sdk_configuration.async_client_supplied
        ):
            await self.sdk_configuration.async_client.aclose()
        self.sdk_configuration.async_client = None
